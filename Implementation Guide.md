<h1>Implementation Guide - Actual Implementation Steps</h1>

The initial idea of using a VM for the project was not feasible due to
processing speed, disk space and other issues loading the AVDs on the
VM. Alternatively, windows 10 local machine was used for the
implementation of project.

The implementation involved the following steps:

1.  Android Studio: Installing Android Studio Ladybug 2024.2.1 Patch
    2, Android Debug Bridge (ADB), JADX-1.5.1, MobSF and Autopsy 4.21.0.

2.  ADB: Configuring the path for ADB in PowerShell command prompt
    for Android Studio project:
    C:\\sers\Eno\AndroidSDK\Platform-tools

3.  AVDs Creation: Creating one AVD each for Google Play Store and
    APKPure apks: "GOOGLE AVD" (Pixel 8 Pro API 35 - GOOGLE AVD) and
    "APKPURE AVD" (Nexus 6 API 35 - APKPURE AVD)- Android 13 (API level
    33)

4.  AVDs Configurations: Configuring AVD to assign internal storage
    of 16gb each

5.  Google Account: Creating Google account for the test
    environment: Joy Onos, Email: MobileForensicPRJ@gmail.com

6.  Installing APKs: Installing APKs on the "GOOGLE AVD" & "APKPURE
    AVD": Subway Surfers, TikTok, Subway Santa Princess Runner and
    Twitter.

7.  On installations of the apps for both AVDs -- user accounts were
    created using the google account details for the apps.

8.  App Activities: Once the user accounts were created on the app -
    user activities were then generated e.g. on TikTok and Twitter,
    posted from other account users were viewed, saved, reposted and
    reacted to. While on Subway Santa Princess Runner which is a gaming
    app - play sessions were generated on the AVDs and changed made on
    the AVDs were saved via Android Studio manager

9.  ADB Pulling APKs: After the previous step above, ADB pull was
    used to extract the user activities data from the APKs on the AVDs
    to specific folders within the project's folder on the local machine
    and then uploaded to JADX for static analysis with two separate
    folders used to save the APKs pulled from the AVDs - folders
    "Emulator 5554" (for Google AVD) and "Emulator 5556" (for APKPure
    AVD), with individual separate projects created in JADX for all APKs
    files in the folders for both AVDs.

10. Hash Comparisons: The hashes of the APK files from both AVDs
    were checked and compared with PowerShell in windows command prompt
    by navigation to the locations where the APK is stored and running
    the command for instance: certutil -hashfile SubwayPrincess_5554.apk SHA256

11. MobSF: MobSF was activated by first running Docker Desktop and
    then the following command on windows command prompt: docker run -it
    -p 8000:8000 -v C:\Users\Eno\\MobSF\Mobile-Security-Framework-MobSF.MobSF
    opensecurity/mobile-security-framework-mobsf
    
    Followed by navigating the localhost:8000 on a web browser. Once
    logged in all APKs for both AVDs were uploaded first and a static
    scan conducted on them
    
    It wasn't feasible to conduct the dynamic scan of all APKs with
    MobSF as envisioned - due to the MobSF's inability to detect the
    running AVDs.
    
    Efforts were made to resolve the issue by setting the configuration
    direction given in the error message but the project time
    constraints restricted the resolution of this issue. The decision
    was made to then use results from the static analysis automatically
    generated by MobSF, for further analysis.

12. Autopsy: By the time the analysis of the scan results from MobSF
    were completed it was too late conducted any further investigation
    using Autopsy and the advice received from project supervisors was
    that Autopsy wasn't important or needed for the project
    investigation

<h1>The Originally Proposed Implementation</h1>

The original plan for the project implementation was to capture all
developments within a VM which included developing an SQLite database to
capture the data to be used in the mobile forensic investigation
project. This database consisted of 6 different tables along with a
python script to automate the database operations. However, the idea of
using a VM for the project, as well as having a database were both
abandoned due to lack of feasibility and after failing efforts.

The following were partially implemented for the virtual machine as
trial for this mobile forensic investigation project:

1.  Android Virtual Device - 2 precisely, one for Google Play Store
    APKs and another for APKPure APKs

2.  JADX was installed for decompiling the Apks and for static analysis

3.  MobSF was installed and used for the dynamic analysis

4.  An SQLite Database to capture users' activities logs:
    user_activity.db

5.  The deployment of python scripts for automation of data extractions
    from the AVDs to the SQLite Database and the user actions from AVDs
    to SQLite Database

6.  The automated creation of 6 tables for the database:
    
    - users: this table captures the users performing the
    activities
    
    - avd_sessions: this table logs when an AVD session starts and
    ends, providing information for the activities within each session
    
    - apk_downloads: this table logs details about APKs downloaded
    or installed on the AVDs
    
    - user_actions: this table logs specific user interactions
    within the AVDs e.g. app launch, permissions granting, interacting
    with specific features within an app on the AVDs
    
    - static_analysis_results: this table stores the results of JADX
    decompilation and static analysis of each APK on the AVDs
    
    - dynamic_analysis_results: this table stores the results of
    MobSF dynamic analysis of each APK on the AVDs

7.  Python script developed (main_project) to perform all actions
    required by the user activity database.

<h1>Python script Functions</h1>

The list of some of major functions created in the main_project.py
python script include:

1.  connect_db(): Establishes a connection to the SQLite database --
    user_activity.db.

2.  Create table if not exists functions: These functions create the
    relevant tables required for the database if they not already exist
    in the database.

3.  Get_or_create_user(username): Gets user id for username or
    creates if it doesn't exist.

4.  Start_avd_session: Logs the start of an avd session.

5.  End-avd_session: Logs the end time of an avd session

6.  Log_apk_download: logs the details of apk installations

7.  Log_user_action: logs the specific details of user action within
    an avd session.

8.  Log_static_analysis_results: logs the results of static
    analysis.

9.  Log_dynamic_analysis_results: Inserts dynamic analysis result
    into the user activity database.

10. Parse_mobsf_dynamic_json: Parse MobSF dynamic analysis JSON
    report and extract summarized data.

11. Run_adb_command:Runs an adb command and processes output.

12. Calculate_files_hashes: Calculates the MD5 and SHA256 hashes of
    a given file.

13. Get_apk_id_from_db: Retrieves an apk id from the database based
    on the package name.

<h1>End to End Database Processes</h1>

Here's the end-to-end process for managing user activity and analysis
results within the SQLite database, user_activity.db, broken down by the
functions:

1. connect_db(): Establishing Database Connection

-   Purpose: This establishes a connection to the user_activity.db
    SQLite database. If the database file doesn\'t exist, SQLite will
    typically create it.

-   Process:

    -   Imports the sqlite3 module.

    -   Attempts to connect to user_activity.db.

    -   Returns the connection object, which will be used for subsequent
        database operations (e.g., creating cursors, committing changes).

    -   Includes error handling for connection failures.

2. Create table if not exists functions: Initializing Schema

-   Purpose: These functions ensure that all necessary tables for
    storing user activity, APK details, and analysis results are
    present in the database. This prevents errors if the database is
    new or if a table was accidentally deleted.

-   Process:

    -   For each required table (e.g., users, avd_sessions,
        apk_downloads, user_actions, static_analysis_results,
        dynamic_analysis_results), a dedicated function would exist
        (e.g., create_users_table_if_not_exists()).

    -   Each function executes a CREATE TABLE IF NOT EXISTS SQL
        statement, defining the table schema (column names, data
        types, primary keys, foreign keys, constraints).

3. Get_or_create_user(username): User Management

-   Purpose: This function handles user identification. It retrieves
     an existing user_id for a given username or creates a new user
     record if the username doesn't already exist, ensuring unique
     user tracking.

-   Process:

    -   Queries the users table to check if the username exists.

    -   If found, returns the corresponding user_id.

    -   If not found, inserts the new username into the users table and
        returns the newly generated user_id.

4. Start_avd_session(user_id): Session Tracking (Start)

-   Purpose: Records the beginning of a user's Android Virtual
    Device (AVD) session, which serves as a container for subsequent
    user actions and analysis logs.

-   Process:

    -   Inserts a new record into the avd_sessions table.

    -   Records the user_id and the current start_time.

    -   Returns the session_id of the newly created session.

5. End_avd_session(session_id): Session Tracking (End)

-   Purpose: To mark the completion of an AVD session, providing a
    clear duration for user activity.

-   Process:

    -   Updates the existing record in the avd_sessions table identified
        by session_id.

    -   Sets the end_time to the current timestamp.

6. Log_apk_download(user_id, package_name, file_path): APK Installation Logging

-   Purpose: To track details of APK installations, including the
    package name and file hashes for later reference and static analysis.

-   Process:

    -   First, calls Calculate_files_hashes(file_path) to get MD5 and SHA256 hashes of the APK.

    -   Inserts a new record into the apk_downloads table.

    -   Records user_id, package_name, file_hash_md5, file_hash_sha256, and the download_time.

    -   Returns the apk_id of the newly logged APK.

7. Log_user_action(session_id, action_type, action_details): User activity Logging

-   Purpose: To log specific, detailed actions performed by a user within an active AVD session, providing a granular audit trail.

-   Process:

    -   Inserts a new record into the user_actions table.

    -   Records the session_id, action_type (e.g., "app_launch", "button_click", "input_text"), action_details 
        (a JSON string or text describing the action), and the timestamp.

8. Log_static_analysis_results(apk_id, results_json): Static Analysis Logging

-   Purpose: To store the results obtained from static analysis tools (e.g., JADX static analysis) for a specific APK.

-   Process:

    -   Inserts a new record into the static_analysis_results table.

    -   Records the apk_id, the results_json (a JSON string containing the full analysis report),
        and the analysis_time.

9. Log_dynamic_analysis_results(apk_id, results_json): Dynamic Analysis Logging

-   Purpose: To store the results obtained from dynamic analysis tools (e.g., MobSF dynamic analysis) for 
    a specific APK.

-   Process:

    -   Inserts a new record into the dynamic_analysis_results table.

    -   Records the apk_id, the results_json (a JSON string containing the full analysis report), and
        the analysis_time.

10. Parse_mobsf_dynamic_json(json_report): Data Extraction from MobSF Reports

-   Purpose: To extract and summarize key information from a raw MobSF dynamic analysis JSON report, 
    making it easier to query and present.

-   Process:

    -   Takes the raw JSON report as input.

    -   Parses the JSON structure.

    -   Extracts relevant fields (e.g., network traffic, API calls, file system changes, 
        detected malware indicators).

    -   Returns a summarized dictionary or object of extracted data, which can then be stored in 
        the analysis_data_json field in a more manageable format or used to populate specific columns 
        if the schema were more normalized.

11. Run_adb_command(command): ADB Interaction

-   Purpose: To execute Android Debug Bridge (ADB) commands, which are essential for interacting with AVDs 
    (e.g., installing APKs, pulling logs, running shell commands).

-   Process:

    -   Uses Python's subprocess module to execute the given command in the shell.

    -   Captures the standard output and standard error.

    -   Provides error handling for command execution failures.

    -   Returns the command's output.

12. Calculate_files_hashes(file_path): File Integrity Check

-   Purpose:To compute cryptographic hash values (MD5 and SHA256) for a given file, primarily used for APK 
    files to ensure integrity and unique identification.

-   Process:

    -   Opens the file in binary read mode.

    -   Reads the file in chunks to handle large files efficiently.

    -   Uses the hashlib module to update MD5 and SHA256 hash objects.

    -   Returns a tuple or dictionary containing the hexadecimal representations of the MD5 and SHA256 hashes.

13. Get_apk_id_from_db(package_name): APK Identification

-   Purpose: To retrieve the internal apk_id from the database based on the APK\'s package_name, which is often 
    a more convenient identifier for external tools or user input.

-   Process:

    -   Queries the apk_downloads table using the package_name.

    -   If found, returns the corresponding apk_id.

    -   If not found, returns None or raises an appropriate error.


